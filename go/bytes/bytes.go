// Package bytes provides utility functions for working with bytes
package bytes

import (
	stdBytes "bytes"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"errors"
)

// Popular returns n most popular bytes from a slice. In the event of a
// tie, returns the bytes occuring latest in the slice.
func Popular(b []byte, n int) ([]byte, error) {
	if len(b) == 0 || n == 0 {
		return nil, errors.New("invalid argument")
	}
	if n > len(b) {
		return nil, errors.New("n exceeds length of slice")
	}

	count := make([]int, n)
	popular := make([]byte, n)
	temp := make([]byte, 1)

	for _, val := range b {
		temp[0] = val

		// If val already exists in popular, move on
		if stdBytes.Contains(popular, temp) {
			continue
		}

		tempCount := stdBytes.Count(b, temp)

		for i := 0; i < n; i++ {
			if tempCount > count[i] {
				// Only set popular[i+1] if popular[i] isn't last member in popular
				if n-i > 1 {
					popular[i+1] = popular[i]
				}
				popular[i] = temp[0]
				count[i] = tempCount
				break
			}
		}

	}
	return popular, nil
}

func HexToBase64(s string) (string, error) {
	if len(s) == 0 {
		return "", errors.New("empty input string")
	}

	bytes, err := hex.DecodeString(s)
	if err != nil {
		return "", err
	}
	result := base64.StdEncoding.EncodeToString(bytes)
	return result, nil
}

// SplitIntoBlocks splits a byte slice into equal length blocks and adds
// padding if necessary.
func SplitIntoBlocks(b []byte, blocksize int) ([][]byte, error) {
	length := len(b)
	rem := length % blocksize
	// n is the total number of blocks to return
	n := length / blocksize

	// If b does not split evenly into blocksize blocks, add an additional
	// block for padding bytes
	if rem != 0 {
		n = n + 1
	}

	blocks := make([][]byte, n)

	for i := 0; i < n; i++ {
		if n-i == 1 {
			blocks[i] = b[i*blocksize:]
		} else {
			blocks[i] = b[i*blocksize : i*blocksize+blocksize]
		}
	}

	if rem != 0 {
		padded := make([]byte, blocksize)
		for i := 0; i < blocksize; i++ {
			padded[i] = 0
		}
		blocks[n-1] = padded

		for k := 0; k < rem; k++ {
			blocks[n-1][k] = b[length-rem+k]
		}
	}
	return blocks, nil
}

// HasRepeatedBlock determines if a given slice has a repeating block
func HasRepeatedBlock(b []byte, blocksize int) (bool, error) {
	blocks, err := SplitIntoBlocks(b, blocksize)
	if err != nil {
		return false, err
	}
	m := make(map[string]bool)

	for _, block := range blocks {
		if m[string(block)] {
			return true, nil
		}
		m[string(block)] = true
	}
	return false, nil
}

// HammingDistance returns the Hamming distance between two byte slices
func HammingDistance(a, b []byte) (int, error) {
	aLen := len(a)
	bLen := len(b)

	if aLen != bLen {
		return -1, errors.New("length mismatch")
	}

	dist := 0
	c := make([]byte, aLen)

	for i := range a {
		c[i] = a[i] ^ b[i]
		dist += HammingWeight(int(c[i]))
	}
	return dist, nil
}

// HammingWeight returns the Hamming weight for a given integer
// From https://en.wikipedia.org/wiki/Hamming_weight
func HammingWeight(x int) int {
	const m1 = 0x5555555555555555
	const m2 = 0x3333333333333333
	const m4 = 0x0f0f0f0f0f0f0f0f
	const h01 = 0x0101010101010101

	x -= (x >> 1) & m1
	x = (x & m2) + ((x >> 2) & m2)
	x = (x + (x >> 4)) & m4
	return (x * h01) >> 56
}

// Random returns a slice of n randomly generated bytes
func Random(n int) ([]byte, error) {
	bytes := make([]byte, n)
	_, err := rand.Read(bytes)
	if err != nil {
		return bytes, err
	}
	return bytes, nil
}
